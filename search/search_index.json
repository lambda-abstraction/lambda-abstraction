{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"what is this?","text":"<p>kinda like a personal blog/article page where i'll try to ocassionally write stuff.</p>"},{"location":"#about-me","title":"about me","text":"<p>im uh, lambda, you can find me in python discord sometimes. im interested in functional programming and types. bye</p>"},{"location":"python-typehints/","title":"introduction","text":""},{"location":"python-typehints/#who-is-this-for","title":"who is this for?","text":"<p>for people who already know the basics of python, and are interested in learning how to enhance their code with type annotations</p>"},{"location":"python-typehints/#what-are-typehints-what-do-they-do-and-dont","title":"what are typehints, what do they do (and dont)?","text":"<p>so, for the python interpreter itself, typehints are kind-of like comments that can be attached to variable assignments, function parameters, their return values, and instance / class attributes, but because of its dynamically typed nature, it was chosen for them to be allowed to be be any python expression, so:</p> <pre><code>x: [\"in theory\"] * 2 = \"this\"\ndef f(y: (\"is\", [2, 4])) -&gt; (lambda z: \"valid\"):\n    ...\nclass C:\n    attr: (\"python\", \"code\")\n</code></pre> <p>but in practice, typehints are optional indicators of types, so instead of arbitrary python expressions, we only use types (classes) (like <code>int</code>, <code>str</code>).</p> <p>to clear out some misconceptions, without using any tools, they:</p> <ul> <li>do not make your code run faster</li> <li>do not prevent from assigning a value of the wrong type to some variable</li> <li>do not make it impossible to call a function with the wrong set of parameters</li> </ul> <p>their usefulness comes largely from the typing ecosystem of libraries and tools built on top of the language, and the fact that they are introspectable (you can write code that would check the type annotations of something, and do something with them: a good example is the <code>@dataclasses.dataclass</code> decorator, that helps generating boilerplate stuff like <code>__init__</code> and <code>__repr__</code> from attribute annotations that are stored in the class's <code>__annotations__</code> attribute).</p> <p>the syntax for them (at the moment of python 3.12), is, like shown above:</p> <pre><code>variable_name: VariableType = value\n\ndef function_name(parameter: ParameterType) -&gt; ReturnType:\n    ...\n\nclass ClassName:\n    attribute_name: AttributeType\n</code></pre> <p>so, what meaning does this have in practice? well, its kind of like an unsigned contract that:</p> <ul> <li><code>variable_name</code> is believed to have a value of type <code>VariableType</code></li> <li><code>function_name</code> was designed to work when you call it with an argument of type   <code>ParameterType</code>, and is supposed to return a value of type <code>ReturnType</code></li> <li>instances of the <code>ClassName</code> class should have an attribute <code>attribute_name</code>   with a value of type <code>AttributeType</code></li> </ul> <p>tools, like typecheckers and IDE's can do a lot of stuff with this information</p> <p>for example, if you annotated <code>x</code> as a <code>str</code>, then you could get autocompletion of <code>str</code> methods on <code>x</code>, like, you could start typing <code>x.</code>, and stuff like <code>.split()</code> would be suggested</p> <p>typecheckers (like mypy and pyright) can verify that your code does work according to the typehints and doesn't try to access methods that dont exist on the type you annotated (e.g. you typehint <code>x</code> as an <code>int</code>, but try to <code>.split()</code> it: <code>int</code> doesnt have <code>split</code> defined, so it'd spot out this as a type error)</p> <p>the general rule i like to follow is to annotate types of parameters as generic as possible, so they can be reusable in more places, and typehint return values / attributes / values as strict as possible, so it is known exactly what the data is and what you can do with it</p>"},{"location":"python-typehints/builtin-types/","title":"builtin-types","text":"<p>so, what types are there even? what do the usual values we use correspond to in types?</p> <pre><code>x: int = 1 # (1)\nx: float = 1.0\nx: bool = True \nx: int = True # (2) \nx: str = \"hi!\"\nx: bytes = b\"hi!\" # (3) \n</code></pre> <ol> <li><code>int</code>s can be passed to where <code>float</code>s are expected</li> <li><code>bool</code> is a sublcass of <code>int</code>, so by liskov substitution principle, we can    use <code>bool</code>s where ints are expected</li> <li>note the <code>b</code> before the string literal: thats a byte string literal :d</li> </ol> <p>Note</p> <p>in all of those cases, the type could be inferred (like, determined without you specifying it) by the type-checker, so providing it was a bit redundant.</p> <p>those are some simple types that make up the values we use most of the time</p> <p>but, what about types that store other things? like lists, dictionaries?</p> <p>those actually have a type parameter, representing the things they store, although when not given, its kind of like saying that it could be anything.</p> <pre><code>xs: list = [0, \"\"] # (1)\nxs: list[int] = [1, 2, 3] # (2)\nxs: set[int] = {0, 1}\nxs: dict[str, int] = {\"x\": 0, \"y\": 1} # (3)\nxs: tuple[int, str, float] = (1, \"hi\", 0.0)\nxs: tuple[int, ...] = (1, 2, 3) # (4) \n</code></pre> <ol> <li>list of <code>Any</code>thing</li> <li>the <code>Type[OtherType]</code> is syntax for so called \"generic\" types: types that    have other types as parameters, in this case, this can be read as \"<code>list</code> of    <code>int</code>s\".</li> <li>there can be multiple type parameters, in dictionaries the first one is for    the type of keys, the second one is for values</li> <li>arbitrary length tuple of integers, the <code>...</code> can have some special meaning    in the context of typing</li> </ol> <p>Note</p> <p>in the case of mutable collections (like <code>list</code>s), providing the type is not redundant: the type cannot be inferred, as you could have e.g. an empty <code>list</code>, that then later gets an <code>int</code> appended to it.</p> <p>what about cases, where we want to represent that a variable / parameter could be of multiple types? for that, we can use union types:</p> <pre><code>x: int | str = 0\nx: int | str = \"\"\n</code></pre> <p>how about typehinting arguments with values that default to <code>None</code> (common python practice)? well, just use a union of your argument type and <code>None</code>: by typecheckers, <code>None</code> is treated as the type of <code>None</code></p>"},{"location":"python-typehints/defining-generics/","title":"defining-generics","text":"<p>hmh.. so, we have already seen generic types like <code>list</code>, but, how do make your own classes generic? and what about functions? can those be generic too? yes! and in python 3.12 with the <code>PEP 695 - Type Parameter Syntax</code></p> <p>lets say we want to define a function that takes a value of some type, lets refer to it as <code>T</code>, and returns a tuple with this value appearing 2 times (like, duplicating it) we could do it like that:</p> <pre><code>def make_pair[T](x: T) -&gt; tuple[T, T]:\n    return (x, x)\n</code></pre> <p>the <code>[T]</code> after the function name means that it has a type variable <code>T</code>, that needs to appear in the signature multiple times to be useful: and it does. what is nice is that not only when we give it some <code>T</code> we get a <code>tuple[T, T]</code> preserving that type, but that when we typehint something as <code>tuple[T, T]</code> but assign it <code>make_pair(something_thats_not_a_T)</code> we get an error!</p> <p>what about classes? its the same syntax: <code>class ClassName[TypeVariables]</code> :d</p>"},{"location":"python-typehints/duck-typing/","title":"duck-typing","text":"<p>now, knowing a bit about typehints, you might want to annotate your functions that loop over something as expecting a <code>list</code> because thats what you usually called it with, but there are other types that we can loop over too, right?</p> <p>thats where duck typing, abstract classes and protocols come into play: the idea behind it is that if something acts like a duck, then it can be treated as a duck.</p> <p>regarding the loop example: you can loop over something if that something is \"iterable\", and for that there is a <code>collections.abc.Iterable</code> type, that is also generic over the type of the item you'll get when iterating over that thing (e.g. a <code>list[int]</code> is an <code>Iterable[int]</code>), so, when you are typehinting a parameter as <code>list</code>: think, should it really be specially a <code>list</code>, or just an <code>Iterable</code>? or maybe a <code>collections.abc.MutableSequence</code>? for something dict-like this would be the <code>collections.abc.Mapping</code> abstract class.</p> <p>i'd recommend to take a look at the types in this module if you want to write nice generic annotations :d</p>"},{"location":"python-typehints/type-aliases/","title":"type-alises","text":"<p>so.. sometimes, when we typehint our code, types can get a bit big and the code starts to look cluttered and its hard to write.. wouldnt it be nice if we could define shorthands for types?</p> <p>and we can! using type aliases, and the <code>type</code> keyword-statement introduced with <code>PEP 695 - Type Parameter Syntax</code>!</p> <p>lets re-use the <code>make_pair</code> example from <code>defining-generics</code></p> <pre><code>def make_pair[T](x: T) -&gt; tuple[T, T]:\n    return (x, x)\n</code></pre> <p>why do we gotta write <code>tuple[T, T]</code>, if all we want is a \"pair\" of <code>T</code>'s? why dont we create a <code>Pair</code> type alias, such that <code>Pair[T]</code> is synonymous to <code>tuple[T, T]</code>? here's how we'd do it:</p> <pre><code>type Pair[T] = tuple[T, T]\n</code></pre> <p>now, <code>Pair[T]</code> is (for typing purposes) exactly the same as <code>tuple[Any, Any]</code> (and <code>Pair</code> with no type argument is like <code>tuple[Any, Any]</code>, although in a later version of python we should be able to override the default types for type variables)</p>"},{"location":"python-typehints/type-variable-bounds-and-constraints/","title":"type-variable-bounds-and-constraints","text":"<p>so, after <code>defining-generics</code> we already can define generic types, but sometimes you want to represent that a type variable should not be arbitrary, but be a subclass of some other type, or implement a protocol / abc, stuff like that, for that, in <code>PEP 695 - Type Parameter Syntax</code> there's a special syntax: <code>[TypeVariableName: BoundType]</code> this means that the <code>TypeVariableName</code> should be a valid subclass of <code>BoundType</code></p> <p>this is very useful even for simple functions like <code>f(x: str) -&gt; str</code> that operate on concrete types when you take into consideration that people can subclass those types and you want to preserve something like \"the returned type is same as given\".</p> <p>what about saying that a type variable can only be one of a set of some predefined variants? this can be achieved by defining constraints on it, like so: <code>[TypeVariableName: (Variant1, ..., VariantN)]</code>. Note that atleast 2 variants are required.</p>"},{"location":"wip-hints/","title":"introduction","text":""},{"location":"wip-hints/#what-are-typehints","title":"what are typehints?","text":"<p>typehints (or, type annotations) are a way of \"hinting\" (so, not enforced) to the reader of the code (which could be you, or another programmer, or a static analysis tool (a typechecker: this will be our best friend when dealing with types)) the type (like, <code>int</code>, <code>str</code>, <code>list</code>) of variables, function parameters and their return types, and attribute types (in classes).</p>"},{"location":"wip-hints/#what-do-they-do-why-use-them","title":"what do they do, why use them?","text":"<p>when developing, they help with formalizing what values you are going to work with, and make it explicit, rather than just \"thinking\" (or, commenting, or putting it in the name of a variable, e.g. <code>things_list</code>) that e.g. your function parameter should be a list and it will return a list back, and, in most cases, given enough annotations typecheckers can prove that your program wont have nasty runtime type-errors, like adding an int to a string, or somehing more complicated that wont be deducible from an error traceback, without you needing to actually run the code.</p> <p>when using something thats typehinted they help with knowing what values to, lets say, pass to a function, and what you'll get back, instead of guessing or needing to open up documentation.</p>"},{"location":"wip-hints/#what-do-they-dont-do","title":"what do they dont do?","text":"<p>sadly or not, typehints on their own do not impact code performance or make type errors impossible. they are more like fancy comments in that sense, although they can be inspected by code, and sometimes that makes great api's, like dataclasses, to make good use of them you need to use a typechecker. there are 2 main ones: mypy and pyright, and a lot of editors have integration for them, for example if you are using vscode - the pylance extension will bring the pyright typechecker and some additional features, just dont forget to enable the typechecking mode in settings (maybe a screenshot here? pyright &gt; analysis &gt; typechecking mode)</p>"},{"location":"wip-hints/#typehints-syntax-and-how-to-understand-what-is-meant-by-typehinted-code","title":"typehints syntax, and how to understand what is meant by typehinted code?","text":"<p>the syntax for them at the moment of python 3.12 is:</p> <pre><code>variable_name: VariableType = value\n\ndef function_name(parameter: ParameterType) -&gt; ReturnType:\n    ...\n\nclass ClassName:\n    attribute_name: AttributeType\n</code></pre> <p>so, what meaning does this have in practice? well, its kind of like an unsigned contract that:</p> <ul> <li><code>variable_name</code> is believed to have a value of type <code>VariableType</code></li> <li><code>function_name</code> was designed to work when you call it with an argument of type   <code>ParameterType</code>, and is supposed to return a value of type <code>ReturnType</code></li> <li>instances of the <code>ClassName</code> class should have an attribute <code>attribute_name</code>   with a value of type <code>AttributeType</code></li> </ul>"},{"location":"wip-hints/#using-typehints-to-prevent-common-errors","title":"using typehints to prevent common errors","text":"<p>lets say you are making a function <code>f</code> for performing some calculations, like</p> <pre><code>def f(x):\n    return (x + 5) ** 2\n</code></pre> <p>and then you want to make the program interactive and call that function with the user input, like <code>f(input())</code>, but then, when running the code, oops.. there is a type error: \"can only concatenate str (not \"int\") to str\". if only we could prevent such errors without needing to run the code, as in a lot of cases, the types of values can be known.. and we can! using typehints and a typechecker, we could typehint that in the function <code>f</code> the parameter <code>x</code> should be a <code>float</code>, like so:</p> <pre><code>def f(x: float):\n    return (x + 5) ** 2\n</code></pre> <p>then, if we do just <code>f(input())</code> - our typechecker would be angry at us, and for good reason! <code>input()</code> returns a <code>str</code>, and a <code>str</code> is not a <code>float</code>, so it prevents us from making a type error, and now in all cases when we call our function - it will help us match the argument type so we wont get an error when actually running our code</p>"},{"location":"wip-hints/#a-bit-about-type-inference","title":"a bit about type inference","text":"<p>so, now that we know that we can typehint our variables wiht <code>variable_name: VariableType = value</code>, should we always do that? even when its, lets say, <code>x: int = 42</code>, isnt that \"obvious\" that 42 is an int? well, yes it is! for literals (like, <code>1</code>, <code>1.5</code>, <code>\"string\"</code>), or expressions that \"obviously\" evaluate to a certain type (like, calling a typehinted function, or accessing an attribute thats typehinted) - typecheckers can infer the type without you needing to specify it</p>"},{"location":"wip-hints/#kind-of-a-cheatsheetexample-of-builtins-and-simplest-generics","title":"kind-of a cheatsheet/example of builtins and simplest generics","text":"<p>so, what are some simple types we can use in typehints that we work with in almost every program?</p> <pre><code>x: int = 1\nx: float = 1.0\nx: bool = True\nx: str = \"hello!\"\nx: bytes = b\"hello!\" # note the b\"\"\n</code></pre> <p>what about storing \"multiple things\" in a variable, like what we use lists, dicts, sets, tuples for? can we specify that we have a list where values are of a specific type? yes we can!</p> <pre><code>xs: list[int] = [1, 2, 3]\nxs: set[int] = {1, 2, 3}\ndata: dict[str, int] = {\"x\": 0, \"y\": 1} # there can be multiple type parameters, in the case of dict, the first one is for the type of the keys, the second is for the values\nxyz: tuple[int, int, int] = (1, 2, 3) # in tuples, we can even specify the type of each value separately!\nxs: tuple[int, ...] = (0, 1, 2, 3) # in the context of typing, `...` can mean special things. for tuples, tuple[SomeType, ...] means a tuple of arbitrary size \n</code></pre> <p>those types can be used without specifying a type parameter, but that way you lose a lot of information and what we use typehints for, so some typecheckers will even report that.</p>"},{"location":"wip-hints/#the-empty-collection-literal-type-inference-problem","title":"the empty collection literal type inference problem","text":"<p>remember about \"type inference\", and that the typechecker can infer the type for literals? well, thats true, but in the case of collections: like lists, dicts, sets, ..., how would it know the type of an empty collection literal, like <code>[]</code> (an empty list)? so in that case, you should specify the type, like:</p> <pre><code>numbers: list[float] = []\n</code></pre>"},{"location":"wip-hints/#subtypes-subclasses","title":"subtypes / subclasses","text":"<p>so, does <code>x: Type</code> mean that <code>x</code> can only be of that specific type <code>Type</code>? well, not really. for example, booleans (<code>True</code> and <code>False</code>) can also be used where <code>int</code>'s are used, because the <code>bool</code> type is a subclass of <code>int</code> (if you are familiar with inheritance, its kinda like, <code>class bool(int):</code>), so <code>x: int = True</code> is perfectly valid.</p>"},{"location":"wip-hints/duck-typing/","title":"duck typing, collections.abc and \"the typing rule\"","text":""},{"location":"wip-hints/duck-typing/#duck-typing","title":"duck typing","text":"<p>in a lot of cases, your parameter doesnt have to be strictly of some specific type, but rather of a type that supports some operation - like, having length, or being able to be iterated over. thats the idea behind \"duck typing\", supported in python through use of protocols and abstract base classes (\"abcs\")</p> <p>luckily, a lot of such types are defined in the standard <code>collections.abc</code> module, for example:</p>"},{"location":"wip-hints/duck-typing/#can-be-looped-over-type-iterable","title":"\"can be looped over\" type - Iterable","text":"<p>if you are implementing something like a <code>sum</code> function, the only thing you really want from the parameter is for you to be able to iterate (loop) over it and get numbers when doing so</p> <p>instead of using <code>list[float]</code>, you could use <code>collections.abc.Iterable[float]</code>, then its valid to pass in anything thats an iterable of floats, be it a list of them, or something else - like a tuple, or a dict whose keys are floats.</p>"},{"location":"wip-hints/duck-typing/#have-length-and-can-be-indexed-type-sequence","title":"\"have length and can be indexed\" type - Sequence","text":"<p>if you accept something that you expect to: have length, can be iterated over and indexed with an int (like a tuple, or a list) - use <code>collections.abc.Sequence</code> if you also want that type to support being mutable (so, tuple wouldnt comply here anymore, only the list) - use <code>collections.abc.MutableSequence</code></p>"},{"location":"wip-hints/duck-typing/#from-key-to-value-type-mapping","title":"\"from key to value\" type - Mapping","text":"<p>if you accept something that you expect to be like a dict, in the sense that it maps values of one type to another (like a dict) - use <code>collections.abc.Mapping</code> (so, instead of a <code>dict[K, V]</code>, you'd use <code>Mapping[K, V]</code>) if you want it to be mutable - same story as with sequence, there is a <code>collections.abc.MutableMapping</code> type. generally, the immutable one is the \"base case\", and a mutable version is a special case with some additional methods</p>"},{"location":"wip-hints/duck-typing/#can-be-called-with-those-parameters-and-return-this-value-type-callable","title":"\"can be called with those parameters and return this value\" type - Callable","text":"<p>sometimes, you accept things that can be called (like, other functions, commonly called \"callbacks\") as parameters. but what is their type? well, it might be a bunch of different types, as not only functions can be called, but anything with a properly defined <code>__call__</code> dunder method, the <code>collections.abc.Callable</code> type helps you typehint those, the syntax is <code>Callable[[Arg1, ..., ArgN], ReturnType]</code>, so, for example, in:</p> <pre><code>def f(x: str, y: int) -&gt; str:\n    ...\n</code></pre> <p><code>Callable[[str, int], str]</code> could be used to represent the type of such a function.</p>"},{"location":"wip-hints/duck-typing/#protocols-introduction","title":"protocols introduction","text":"<p>There is another option, to use <code>Protocols</code> and define the <code>__call__</code> method signature yourself, in which case you'd also be able to specify the names of parameters, making it more explanatory.</p> <p>so, continuing the example, it would be like:</p> <pre><code>from typing import Protocol\n\nclass Callback(Protocol):\n    def __call__(self, x: str, y: int) -&gt; str:\n        ...\n</code></pre> <p>as you could guess - this is usable not only with <code>__call__</code>, you can use this to define things like in <code>collections.abc</code> yourself :d</p> <p>Resource</p> <p>for magic methods like <code>__call__</code> you can look into the <code>python data model</code> page.</p>"},{"location":"wip-hints/duck-typing/#the-typing-rule","title":"the typing rule","text":"<p>overall, try to be generic in parameter types, so your functions will be usable with lots of different types and you wont need to convert everything to a concrete type just to pass the typechecker, and strict in return types, so it will be known exactly what is the result and what you can do with it</p>"}]}