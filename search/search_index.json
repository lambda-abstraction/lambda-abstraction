{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"what is this?","text":"<p>kinda like a personal blog/article page where i'll try to ocassionally write stuff.</p>"},{"location":"#about-me","title":"about me","text":"<p>im uh, lambda, you can find me in python discord sometimes. im interested in functional programming and types. bye</p>"},{"location":"python-typehints/","title":"introduction","text":""},{"location":"python-typehints/#who-is-this-for","title":"who is this for?","text":"<p>for people who already know the basics of python, and are interested in learning how to enhance their code with type annotations</p>"},{"location":"python-typehints/#what-are-typehints-what-do-they-do-and-dont","title":"what are typehints, what do they do (and dont)?","text":"<p>so, for the python interpreter itself, typehints are kind-of like comments that can be attached to variable assignments, function parameters, their return values, and instance / class attributes, but because of its dynamically typed nature, it was chosen for them to be allowed to be be any python expression, so:</p> <pre><code>x: [\"in theory\"] * 2 = \"this\"\ndef f(y: (\"is\", [2, 4])) -&gt; (lambda z: \"valid\"):\n    ...\nclass C:\n    attr: (\"python\", \"code\")\n</code></pre> <p>but in practice, typehints are optional indicators of types, so instead of arbitrary python expressions, we only use types (classes) (like <code>int</code>, <code>str</code>).</p> <p>to clear out some misconceptions, without using any tools, they:</p> <ul> <li>do not make your code run faster</li> <li>do not prevent from assigning a value of the wrong type to some variable</li> <li>do not make it impossible to call a function with the wrong set of parameters</li> </ul> <p>their usefulness comes largely from the typing ecosystem of libraries and tools built on top of the language, and the fact that they are introspectable (you can write code that would check the type annotations of something, and do something with them: a good example is the <code>@dataclasses.dataclass</code> decorator, that helps generating boilerplate stuff like <code>__init__</code> and <code>__repr__</code> from attribute annotations that are stored in the class's <code>__annotations__</code> attribute).</p> <p>the syntax for them (at the moment of python 3.12), is, like shown above:</p> <pre><code>variable_name: VariableType = value\n\ndef function_name(parameter: ParameterType) -&gt; ReturnType:\n    ...\n\nclass ClassName:\n    attribute_name: AttributeType\n</code></pre> <p>so, what meaning does this have in practice? well, its kind of like an unsigned contract that:</p> <ul> <li><code>variable_name</code> is believed to have a value of type <code>VariableType</code></li> <li><code>function_name</code> was designed to work when you call it with an argument of type   <code>ParameterType</code>, and is supposed to return a value of type <code>ReturnType</code></li> <li>instances of the <code>ClassName</code> class should have an attribute <code>attribute_name</code>   with a value of type <code>AttributeType</code></li> </ul> <p>tools, like typecheckers and IDE's can do a lot of stuff with this information</p> <p>for example, if you annotated <code>x</code> as a <code>str</code>, then you could get autocompletion of <code>str</code> methods on <code>x</code>, like, you could start typing <code>x.</code>, and stuff like <code>.split()</code> would be suggested</p> <p>typecheckers (like mypy and pyright) can verify that your code does work according to the typehints and doesn't try to access methods that dont exist on the type you annotated (e.g. you typehint <code>x</code> as an <code>int</code>, but try to <code>.split()</code> it: <code>int</code> doesnt have <code>split</code> defined, so it'd spot out this as a type error)</p> <p>the general rule i like to follow is to annotate types of parameters as generic as possible, so they can be reusable in more places, and typehint return values / attributes / values as strict as possible, so it is known exactly what the data is and what you can do with it</p>"},{"location":"python-typehints/builtin-types/","title":"builtin-types","text":"<p>so, what types are there even? what do the usual values we use correspond to in types?</p> <pre><code>x: int = 1 # (1)\nx: float = 1.0\nx: bool = True \nx: int = True # (2) \nx: str = \"hi!\"\nx: bytes = b\"hi!\" # (3) \n</code></pre> <ol> <li><code>int</code>s can be passed to where <code>float</code>s are expected</li> <li><code>bool</code> is a sublcass of <code>int</code>, so by liskov substitution principle, we can    use <code>bool</code>s where ints are expected</li> <li>note the <code>b</code> before the string literal: thats a byte string literal :d</li> </ol> <p>Note</p> <p>in all of those cases, the type could be inferred (like, determined without you specifying it) by the type-checker, so providing it was a bit redundant.</p> <p>those are some simple types that make up the values we use most of the time</p> <p>but, what about types that store other things? like lists, dictionaries?</p> <p>those actually have a type parameter, representing the things they store, although when not given, its kind of like saying that it could be anything.</p> <pre><code>xs: list = [0, \"\"] # (1)\nxs: list[int] = [1, 2, 3] # (2)\nxs: set[int] = {0, 1}\nxs: dict[str, int] = {\"x\": 0, \"y\": 1} # (3)\nxs: tuple[int, str, float] = (1, \"hi\", 0.0)\nxs: tuple[int, ...] = (1, 2, 3) # (4) \n</code></pre> <ol> <li>list of <code>Any</code>thing</li> <li>the <code>Type[OtherType]</code> is syntax for so called \"generic\" types: types that    have other types as parameters, in this case, this can be read as \"<code>list</code> of    <code>int</code>s\".</li> <li>there can be multiple type parameters, in dictionaries the first one is for    the type of keys, the second one is for values</li> <li>arbitrary length tuple of integers, the <code>...</code> can have some special meaning    in the context of typing</li> </ol> <p>Note</p> <p>in the case of mutable collections (like <code>list</code>s), providing the type is not redundant: the type cannot be inferred, as you could have e.g. an empty <code>list</code>, that then later gets an <code>int</code> appended to it.</p> <p>what about cases, where we want to represent that a variable / parameter could be of multiple types? for that, we can use union types:</p> <pre><code>x: int | str = 0\nx: int | str = \"\"\n</code></pre> <p>how about typehinting arguments with values that default to <code>None</code> (common python practice)? well, just use a union of your argument type and <code>None</code>: by typecheckers, <code>None</code> is treated as the type of <code>None</code></p>"}]}